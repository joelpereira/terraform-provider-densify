package provider

import (
	"context"
	"fmt"

	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	"github.com/joelpereira/densify-api-client-go"
)

// Ensure the implementation satisfies the expected interfaces.
var (
	_ datasource.DataSource              = &densifyDataSourceCloud{}
	_ datasource.DataSourceWithConfigure = &densifyDataSourceCloud{}
)

// NewDensifyDataSource is a helper function to simplify the provider implementation.
func NewDensifyDataSourceCloud() datasource.DataSource {
	return &densifyDataSourceCloud{}
}

// densifyDataSource is the data source implementation.
type densifyDataSourceCloud struct {
	// client  *hashicups.Client
	client *densify.Client
}

// densifyRecoModel maps Densify Recommendation schema data.
type densifyDataSourceCloudModel struct {
	EntityId            types.String  `tfsdk:"entity_id"`
	Name                types.String  `tfsdk:"name"`
	CurrentInstance     types.String  `tfsdk:"current_type"`
	RecommendedInstance types.String  `tfsdk:"recommended_type"`
	ApprovedInstance    types.String  `tfsdk:"approved_type"`
	OptimizationType    types.String  `tfsdk:"optimization_type"`
	AccountRef          types.String  `tfsdk:"account_id"`
	ApprovalType        types.String  `tfsdk:"approval_type"`
	SavingsEstimate     types.Float64 `tfsdk:"savings_estimate"`
	EffortEstimate      types.String  `tfsdk:"effort_estimate"`
}

// Metadata returns the data source type name.
func (d *densifyDataSourceCloud) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_cloud"
}

// Schema defines the schema for the data source.
func (d *densifyDataSourceCloud) Schema(_ context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Description: "Fetches a Recommendation for Cloud Compute resources from the Densify API.",
		Attributes: map[string]schema.Attribute{
			"entity_id": schema.StringAttribute{
				Computed:    true,
				Description: "Unique identifier for cloud resource.",
			},
			"name": schema.StringAttribute{
				Computed:    true,
				Description: "System name for the compute resource.",
			},
			"current_type": schema.StringAttribute{
				Computed:    true,
				Description: "Current instance type.",
			},
			"recommended_type": schema.StringAttribute{
				Computed:    true,
				Description: "Recommended instance type generated by Densify.",
			},
			"approved_type": schema.StringAttribute{
				Computed:    true,
				Description: "The approved instance type. This starts with the fallback instance or the current instance type, and may only be replaced by the recommended instance if 'Approval_Type' is set.",
			},
			"optimization_type": schema.StringAttribute{
				Computed:    true,
				Description: "Type of optimization. Ex. Downsize, Upsize, Terminate, etc.",
			},
			"account_id": schema.StringAttribute{
				Computed:    true,
				Description: "Account reference identifier.",
			},
			"approval_type": schema.StringAttribute{
				Computed:    true,
				Description: "Approval type. If ITSM integration has been enabled, this field will identify whether the recommendation has been reviewed & approved.",
			},
			"savings_estimate": schema.Float64Attribute{
				Computed:    true,
				Description: "Estimated monthly savings by applying the optimization recommendation.",
			},
			"effort_estimate": schema.StringAttribute{
				Computed:    true,
				Description: "Estimated effort required by applying optimization recommendation. Ex. none, low, med, high.",
			},
		},
	}
}

// Configure adds the provider configured client to the data source.
func (d *densifyDataSourceCloud) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
	tflog.Trace(ctx, "Configuring Densify API client")
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*densify.Client)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Data Source Configure Type",
			fmt.Sprintf("Expected *densify.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)

		return
	}

	d.client = client
}

// Read refreshes the Terraform state with the latest data.
func (d *densifyDataSourceCloud) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {
	tflog.Trace(ctx, "Reading Densify API client")
	var state densifyDataSourceCloudModel

	tflog.Debug(ctx, "Densify API client: calling GetAccountOrCluster")
	_, err := d.client.GetAccountOrCluster()
	if err != nil {
		if d.client.Query.SkipErrors {
			// skip the error message
			return
		}
		resp.Diagnostics.AddError(
			"Unable to Find Densify Account Number/Name",
			err.Error(),
		)
		return
	}
	tflog.Trace(ctx, "Densify API client: GetAccountOrCluster: success")
	tflog.Debug(ctx, "Densify API client: calling GetDensifyRecommendation")
	reco, err := d.client.GetDensifyRecommendation()
	if err != nil {
		resp.Diagnostics.AddError(
			"Unable to Find Densify Recommendation",
			err.Error(),
		)
		return
	}
	tflog.Trace(ctx, "Densify API client: GetDensifyRecommendation: success")

	// if we didn't get a recommendation, return an empty one (instead of nil)
	if reco == nil {
		reco = &densify.DensifyRecommendation{}
	}

	if reco != nil {
		// Map response body to model
		state.EntityId = types.StringValue(reco.EntityId)
		state.Name = types.StringValue(reco.Name)
		state.CurrentInstance = types.StringValue(reco.CurrentType)
		state.RecommendedInstance = types.StringValue(reco.RecommendedType)
		state.ApprovedInstance = types.StringValue(reco.ApprovedType)
		state.OptimizationType = types.StringValue(reco.RecommendationType)
		state.AccountRef = types.StringValue(reco.AccountIdRef)
		state.ApprovalType = types.StringValue(reco.ApprovalType)
		state.SavingsEstimate = types.Float64Value(float64(reco.SavingsEstimate))
		state.EffortEstimate = types.StringValue(reco.EffortEstimate)

		// recoState := densifyDataSourceModel{
		// 	EntityId:        types.StringValue(reco.EntityId),
		// 	Name:            types.StringValue(reco.Name),
		// 	CurrentType:     types.StringValue(reco.CurrentType),
		// 	RecommendedType: types.StringValue(reco.RecommendedType),
		// ID:          types.Int64Value(int64(coffee.ID)),
		// Teaser:      types.StringValue(coffee.Teaser),
		// Description: types.StringValue(coffee.Description),
		// Price:       types.Float64Value(coffee.Price),
		// Image:       types.StringValue(coffee.Image),
		// }
		// for _, ingredient := range coffee.Ingredient {
		// 	recoState.Ingredients = append(coffeeState.Ingredients, coffeesIngredientsModel{
		// 		ID: types.Int64Value(int64(ingredient.ID)),
		// 	})
		// }
		// state.Recommendation = append(state.Recommendation, recoState)

		// for _, reco := range *reco {
		// 	recoState := densifyRecoModel{
		// 		EntityId: types.StringValue(reco.EntityId),
		// 		Name:     types.StringValue(reco.Name),
		// 		// ID:          types.Int64Value(int64(coffee.ID)),
		// 		// Teaser:      types.StringValue(coffee.Teaser),
		// 		// Description: types.StringValue(coffee.Description),
		// 		// Price:       types.Float64Value(coffee.Price),
		// 		// Image:       types.StringValue(coffee.Image),
		// 	}

		// 	// for _, ingredient := range coffee.Ingredient {
		// 	// 	recoState.Ingredients = append(coffeeState.Ingredients, coffeesIngredientsModel{
		// 	// 		ID: types.Int64Value(int64(ingredient.ID)),
		// 	// 	})
		// 	// }

		// 	state.Recommendations = append(state.Recommendations, recoState)
		// }

	}

	// Set state
	diags := resp.State.Set(ctx, &state)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
}
